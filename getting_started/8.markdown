---
layout: getting_started
title: 8 Modules
guide: 8
---

# {{ page.title }}

In Elixir, we group several functions into modules. In the previous chapters, we have used many different modules, like [the `String` module](/docs/stable/String.html):

```iex
iex> String.length "hello"
5
```

In order to create our own modules in Elixir, we use the `defmodule` macro and `def` to define our functions:

```iex
iex> defmodule Math do
...>   def sum(a, b) do
...>     a + b
...>   end
...> end

iex> Math.sum(1, 2)
3
```

In the following sections, our examples are going to get a bit more complex and it can be tricky to type them all in the shell. It is about time for us to learn how to compile Elixir code and also how to run Elixir scripts.

## 8.1 Compilation

Most of the time it is convenient to write modules into files so they can be compiled and reused. Let's assume we have a file named `math.ex` with the following contents:

```elixir
defmodule Math do
  def sum(a, b) do
    a + b
  end
end
```

This file can be compiled using `elixirc`:

    elixirc math.ex

This will generate a file named `Elixir.Math.beam` containing the bytecode for the defined module. If we start `iex` again, our module definition will be available (considering `iex` is being started in the same directory the bytecode file is):

```iex
iex> Math.sum(1, 2)
3
```

Elixir projects are usually organized into three directories:

* ebin - contains the compiled bytecode
* lib - contains elixir code (usually `.ex` files)
* test - contains tests (usually `.exs` files)

When working on actual projects, our build tool called `mix` will be responsible to compile and set up the proper paths for you. For learning purposes, Elixir supports scripted modes, which is more flexible and does not generate any compiled artifacts.

## 8.2 Scripted mode

In addition to the Elixir file extension `.ex`, Elixir also supports `.exs` files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. `.ex` files are meant to be compiled while `.exs` files are used for scripting, without the need for compilation. For instance, one can create a file called `math.exs`:

```elixir
defmodule Math do
  def sum(a, b) do
    a + b
  end
end

IO.puts Math.sum(1, 2)
```

And execute it as:

    elixir math.exs

The file will be compiled in memory and executed, printing "3" as the result. No bytecode file will be created. In the following examples, we recommend you to write your code into script files and execute them as shown above.

## 8.3 Named functions

Inside a module, we can define functions with `def/2` and private functions with `defp/2`. A function defined with `def/2` is available to be invoked from other modules while a private function can only be invoked locally.

```elixir
defmodule Math do
  def sum(a, b) do
    do_sum(a, b)
  end

  defp do_sum(a, b) do
    a + b
  end
end

Math.sum(1, 2)    #=> 3
Math.do_sum(1, 2) #=> ** (UndefinedFunctionError)
```

Function declarations also support guards and multiple clauses. If a function has several clauses, Elixir will try each clause until it finds one that matches. Here is the implementation of a function that checks if the given number is zero or not:

```elixir
defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_number(x) do
    false
  end
end

Math.zero?(0)  #=> true
Math.zero?(1)  #=> false

Math.zero?([1,2,3])
#=> ** (FunctionClauseError)
```

Giving an argument that does not match any of the clauses raises an error.

## 8.4 Function capturing

Throughout this tutorial, we have been using the notation `name/arity` to refer to functions. It happens this notation can actually be used to retrieve a module function as a function type. Let's start `iex` and run the `math.exs` file defined above:

    $ iex math.exs

```iex
iex> Math.zero?(0)
true
iex> fun = &Math.zero?/1
&Math.zero?/1
iex> is_function fun
true
iex> fun.(0)
true
````

Local or imported functions, like `is_function/1`, we can be captured without the module:

```iex
iex> &is_function/1
&:erlang.is_function/1
iex> (&is_function/1).(fun)
true
```

Note the capture syntax can also be used as a shortcut for defining functions:

```iex
iex> fun = &(&1 + 1)
#Function<6.71889879/1 in :erl_eval.expr/5>
iex> fun.(1)
2
```

The `&1` represents the first argument passed into the function. The syntax above is useful for short function definitions. You can read more about the capture operator `&` in [the `Kernel.SpecialForms` documentation](/docs/stable/Kernel.SpecialForms.html).

This finishes our short introduction to modules. In the next chapters, we will learn how to define default arguments, how to use functions for recursion, explore Elixir lexical directives that can be used for importing functions from other modules, as well as module attributes.

---
layout: getting_started
title: 4 Pattern matching
guide: 4
---

# {{ page.title }}

In this chapter, we will show how the `=` operator in Elixir is actually a match operator and how to use it to pattern match inside data structures. Finally, we will learn about the pin operator `^` used to access previously bound values.

## 4.1 The match operator

We have used the `=` operator a couple times to "assign" variables in Elixir.

```iex
iex> x = 1
1
iex> x
1
```

However, the `=` operator is actually called *the match operator*. Let's see why:

```iex
iex> 1 = x
1
iex> 2 = x
** (MatchError) no match of right hand side value: 1
```

Notice we `1 = x` is a valid expression and it matched because both the left and right side are equal to 1. When the sides do not match, a `MatchError` is reported.

Also, in Elixir parlance, we don't say a variable is assigned. We say a variable is bound or not. A variable can only be bound while on the left side:

```iex
iex> 1 = unknown
** (RuntimeError) undefined function: unknown/0
````

Since there is no variable unknown previously defined, Elixir imagined you were trying to call a function named `unknown/0`, but there isn't such function.

## 4.2 Pattern matching

The match operator cannot only be used to match against direct values but they are also useful for destructuring more complex data types. For example, we can pattern match on tuples:

```iex
iex> {a, b, c} = {:hello, "world", 42}
{:hello, "world", 42}
iex> a
:hello
iex> b
"world"
```

A pattern match will error in case the sides can't match. This is, for example, the case when the tuples have different sizes:

```iex
iex> {a, b, c} = {:hello, "world"}
** (MatchError) no match of right hand side value: {:hello, "world"}
```

And also when comparing different types:

```iex
iex> {a, b, c} = [:hello, "world", "!"]
** (MatchError) no match of right hand side value: [:hello, "world", "!"]
```

More interestingly, we can match on specific values. The example below asserts that the left side will only match the right side in case the right side is a tuple that starts with the atom `:ok`:

```iex
iex> {:ok, result} = {:ok, 13}
{:ok, 13}
iex> result
13

iex> {:ok, result} = {:error, :oops}
** (MatchError) no match of right hand side value: {:error, :oops}
```

We can also pattern match on lists:

```iex
iex> [a, b, c] = [1, 2, 3]
[1, 2, 3]
iex> a
1
```

Lists also supporting matching on its head and tail:

```iex
iex> [head | tail] = [1, 2, 3]
[1, 2, 3]
iex> head
1
iex> tail
[2, 3]
```

Similar to the `hd/1` and `tl/1` functions, we can't match an empty list with a head and tail pattern:

```iex
iex> [h|t] = []
** (MatchError) no match of right hand side value: []
```

The `[head | tail]` format is not only used on pattern matching but also for prepending items to a list:

```iex
iex> list = [1, 2, 3]
[1, 2, 3]
iex> [0|list]
[0, 1, 2, 3]
```

Pattern matching allows developers to easily destruct data types such as tuples and lists. As we will see in following chapters, it is one of the foundations of recursion in Elixir and applies to other types as well, like maps and binaries.

## 4.3 The pin operator

Variables in Elixir can be rebound:

```iex
iex> x = 1
1
iex> x = 2
2
```

The pin operator `^` can be used when there is no interest in rebinding a variable but rather matching against its value (prior to the match):

```iex
iex> x = 1
1
iex> ^x = 2
** (MatchError) no match of right hand side value: 2
iex> {x, ^x} = {2, 1}
{2, 1}
iex> x
2
```

Finally, notice that if a variable is mentioned more than once in a pattern, all references should bind to the same pattern:

```iex
iex> {x, x} = {1, 1}
1
iex> {x, x} = {1, 2}
** (MatchError) no match of right hand side value: {1, 2}
```

This finishes our introduction to pattern matching. As we will see in the next chapter, pattern matching is very common in many language constructs and, if you are not familiar with it from other languages, you will get the hang of it with just a bit of practice! So let's talk some control flow structures, like `case` and `cond`, before we move towards more advanced data-types, likes binaries, keyword lists and maps.
